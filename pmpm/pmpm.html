<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <title>pmpm</title>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="stylesheet" type="text/css" href="./pmpm.css" />
</head>
<body>


<div id="status"></div>


<div class="markdown-body" id="content"></div>


<!-- pmpm script -->
<script>

// Viz and Katex are loaded dynamically on demand
function loadScript(src, integrity, crossOrigin)
{
    const script = document.createElement('script');
    if(integrity !== undefined)
        script.integrity = integrity;
    if(crossOrigin !== undefined)
        script.crossOrigin = crossOrigin;
    script.src = src;
    const promise = new Promise((resolve, reject) => {
        script.onload = resolve;
        script.onerror = reject;
    });
    document.head.append(script);
    return promise;
}

function loadStyle(src, integrity, crossOrigin)
{
    const style = document.createElement('link');
    style.rel = 'stylesheet';
    style.type = 'text/css';
    style.integrity = integrity;
    style.crossOrigin = crossOrigin;
    style.href = src;
    const promise = new Promise((resolve, reject) => {
        style.onload = resolve;
        style.onerror = reject;
    });
    document.head.append(style);
    return promise;
}


let _vizLoaded = false;
let _vizLoadPromise;
async function getViz() {
    if(!_vizLoaded) {
        if(_vizLoadPromise === undefined) {
            _vizLoadPromise = Promise.all([
                loadScript('https://cdn.tutorialjinni.com/viz.js/2.1.2/viz.js'),
                loadScript('https://cdn.tutorialjinni.com/viz.js/2.1.2/lite.render.js')
            ]);
        }
        await _vizLoadPromise;
        _vizLoaded = true;
    }

    return new Viz();
}

let _katex;
let _katexLoadPromise;
async function getKatex() {
    if(_katex === undefined) {
        if(_katexLoadPromise === undefined) {
            _katexLoadPromise = Promise.all([
                loadScript('https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js', 'sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz', 'anonymous'),
                loadStyle('https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css', 'sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq', 'anonymous')
            ]);
        }
        await _katexLoadPromise;
        _katex = katex;
    }
    return _katex;
}


// global variables
const status = document.getElementById('status');
const container = document.getElementById('content');
const children = container.children;
const hashAttr = 'data-hash';
let fpath = (new URLSearchParams(window.location.search)).get('fpath');


// body
async function renderBlockContentsAsync(el)
{
    // Render katex
    for(const mathEl of el.getElementsByClassName('math')) {
        const latexStr = mathEl.textContent;
        try {
            const katex = await getKatex();
            katex.render(latexStr, mathEl, {
                displayMode: mathEl.classList.contains('display')
            });
        } catch(e) {
            const errEl = document.createElement('span');
            errEl.style.color = 'red';
            errEl.innerText = latexStr + ' ('+e.message+')';
            mathEl.appendChild(errEl);
        }
    }

    // Render viz
    for(const vizEl of el.getElementsByClassName('dot-parse')) {
        const viz = await getViz();
        viz.renderString(el.textContent, {engine: 'dot', format:'svg'}).then(svg => el.innerHTML = svg);
    }
}

function swapElements(obj1, obj2) {
    // save the location of obj2
    const next2 = obj2.nextSibling;
    // special case for obj1 is the next sibling of obj2
    if (next2 === obj1) {
        // just put obj1 before obj2
        container.insertBefore(obj1, obj2);
    } else {
        // insert obj2 right before obj1
        container.insertBefore(obj2, obj1);

        // now insert obj1 where obj2 was
        if (next2) {
            // if there was an element after obj2, then insert obj1 right before that
            container.insertBefore(obj1, next2);
        } else {
            // otherwise, just append as last child
            container.appendChild(obj1);
        }
    }
}

function findFirstChangedChild(currentChildNodes, previousChildNodes)
{
    const nchildren = currentChildNodes.length;
    for(let i = 0; i < nchildren; i++) {
        const curChild = currentChildNodes[i];
        const prevChild = previousChildNodes[i];
        if(!prevChild)
            return curChild;
        if(!curChild.isEqualNode(prevChild)) {
            if(curChild.nodeType != Node.ELEMENT_NODE)
                return curChild.parentNode;
            else if(!curChild.childNodes.length)
                return curChild;
            else
                return findFirstChangedChild(curChild.childNodes, prevChild.childNodes);
        }
    }
    return currentChildNodes[nchildren-1];
}

function updateBodyFromBlocks(contentnew)
{
    // Go through new content blocks. At each step we ensure that <div id="content"> matches the new contents up to block i
    let i;
    let scrollTarget;
    let scrollTargetCompare;
    for(i = 0; i < contentnew.length; i++) {

        const newhash = contentnew[i][0];

        // Check if node with hash of new block already exists
        // If it exists: Take it and move it to position i if needed
        // If it doesn't exist: Create it and insert it
        // Only check at position >= i so that we don't move away nodes we already put at positions < i
        // This is important if multiple content elements with the same hash exist
        let j;
        for(j = i; j < children.length && children[j].getAttribute(hashAttr) != newhash; j++);
        if(j < children.length) {
            // Hash does exist -- at position j
            if(j != i) {
                swapElements(children[j], children[i]);
                if (scrollTarget === undefined) {
                    scrolltarget = children[i];
                    scrollTargetCompare = children[j];
                }
            }
        } else {
            // Hash does not exist, creating new
            const newEl = document.createElement('div');
            newEl.setAttribute(hashAttr, newhash);
            newEl.innerHTML = contentnew[i][1];
            container.insertBefore(newEl, children[i]);

            // asynchronously render latex and viz if necessary
            renderBlockContentsAsync(newEl);

            if (scrollTarget === undefined) {
                scrollTarget = newEl;
                scrollTargetCompare = children[i + 1];
            }
        }
    }

    // Now all non-needed elements from original content should be at the end and we can remove them
    while(children.length > i)
        container.removeChild(children[children.length-1])

    // scroll first changed block into view
    // TODO: Delay until async katex / viz rendering is done?
    if (scrollTarget !== undefined) {
        if(scrollTargetCompare && scrollTarget.childNodes.length)
            scrollTarget = findFirstChangedChild(scrollTarget.childNodes, scrollTargetCompare.childNodes);
        window.scrollTo({top:
            scrollTarget.getBoundingClientRect().top +
            window.pageYOffset - window.innerHeight / 5})
    }
}

// websockets
function showStatusWarning(text)
{
    status.style.display = 'block';
    status.style.backgroundColor = 'yellow';
    status.innerText = text;
}

function showStatusInfo(text)
{
    status.style.display = 'block';
    status.style.backgroundColor = 'lightgray';
    status.innerText = text;
}

function hideStatus()
{
    status.style.display = 'none';
}

const websocketUrl = "ws://localhost:9877/";
let _websocket;
let _websocketResolve;
let _websocketPromise = new Promise((resolve, reject) => {
    _websocketResolve = resolve;
});
async function initWebsocket()
{
    showStatusInfo('Connecting to '+websocketUrl+'...');

    _websocket = new WebSocket(websocketUrl);
    _websocket.onopen = function() {
        hideStatus();
        _websocketResolve();
    };
    _websocket.onmessage = function (event) {
        // parse message
        const message = JSON.parse(event.data);

        // update page
        updateBodyFromBlocks(message.htmlblocks);

        // change browser url
        const url = window.location.pathname + "?fpath=" + encodeURIComponent(message.fpath);
        if (message.fpath !== "" && message.fpath != fpath) {
            fpath = message.fpath;
            window.document.title = 'pmpm - '+fpath;
            history.pushState({fpath:fpath}, url, url);
        } else {
            history.replaceState({fpath:fpath}, url, url);
        }

        // hide status, if still shown from reconnect
        hideStatus();
    };

    _websocket.onclose = _websocket.onerror = function() {
        if(_websocket) {
            _websocketPromise = new Promise((resolve, reject) => {
                _websocketResolve = resolve;
            });
            _websocket = null;
            _websocketPromise.then(() => showStatusInfo('Just connected to '+websocketUrl+'. Shown content is possibly outdated.'));
            setTimeout(initWebsocket, 5000);
            showStatusWarning('Error connecting to '+websocketUrl+'. Retrying in 5 seconds...');
        }
    };
}

async function getWebsocket()
{
    await _websocketPromise;
    return _websocket;
}

window.onpopstate = history.onpushstate = function (event) {
    fpath = event.state.fpath;
    window.document.title = 'pmpm - '+fpath;
    getWebsocket().then((websocket) => websocket.send(fpath));
};

// Load websocket
initWebsocket();

// Load initial document if any
if(fpath) {
    window.document.title = 'pmpm - '+fpath;
    getWebsocket().then((websocket) => websocket.send(fpath));
}

</script>


</body>
</html>
