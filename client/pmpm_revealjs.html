<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>pmpm</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./3rdparty/reveal.js/4.0.0/dist/reset.css">
  <link rel="stylesheet" href="./3rdparty/reveal.js/4.0.0/dist/reveal.css">
  <link rel="stylesheet" href="./pmpm_revealjs.css">
  <link rel="stylesheet" href="./3rdparty/reveal.js/4.0.0/dist/theme/solarized.css" id="theme">
</head>
<body>



<div id="status"></div>

<div class="reveal markdown-body">
    <div class="slides" id="content"><section><i>Pipe something to pmpm</i></section></div><!-- Fake section so that Reveal.initialize() works -->
    <div id="references">
        <h1 class="unnumbered" id="bibliography"></h1>
    </div>
    <div class="footnotes" style="display: none;">
        <hr>
        <div id="footnotes"><ol></ol></div><!-- Fake ol, corresponding to the fake <section> above -->
    </div>
</div>



<!-- pmpm.js script -->
<script src="./pmpm.js"></script>



<script src="./3rdparty/reveal.js/4.0.0/dist/reveal.js"></script>

<script>

findFirstChangedChild = (currentChildNodes, previousChildNodes) => {
    const nchildren = currentChildNodes.length;
    for(let i = 0; i < nchildren; i++) {
        const curChild = currentChildNodes[i];
        const prevChild = previousChildNodes[i];
        if(!prevChild)
            return curChild;
        if(!curChild.isEqualNode(prevChild)) {
            if(curChild.childNodes.length) {
                const tmp = findFirstChangedChild(curChild.childNodes, prevChild.childNodes);
                // Reveal.js changes attributes of <section>s. Don't take this as firstChangedChild
                if(curChild.tagName === 'SECTION' && tmp === undefined) {
                    console.log('no change in children of <section> found -- continuing as if equal');
                } else {
                    return tmp;
                }
            } else {
                return curChild;
            }
        }
    }
    // Nothing found, difference is probably in attributes of parent
    return;
};


scrollToFirstChange = (firstChange, firstChangeCompare) => {

    // sync
    Reveal.sync();

    // Find first changed slide/subslide
    let slide;
    if(firstChangeCompare && firstChange.childNodes.length) {
        slide = findFirstChangedChild(firstChange.childNodes, firstChangeCompare.childNodes);
        while(slide && slide.tagName != 'SECTION')
            slide = slide.parentNode;
    }

    // avoid flickering
    // TODO: Temporarily disable fragment transitions?
    var oldConfig = Object.assign({}, Reveal.getConfig());
    Reveal.configure({transition: "none",
                      backgroundTransition: "none"})
    // Scroll to first changed slide/subslide
    if(slide !== undefined) {
        const newIndices = Reveal.getIndices(slide);
        console.log('slide indices', newIndices);
        // TODO: What about fragments?
        //       Show all fragments on changed slide? (+Infinity instead of newIndices.f)
        Reveal.slide(newIndices.h, newIndices.v, +Infinity);
    } else  // TODO: When slide is removed, jump to neighbouring slide instead of slide(0)
        Reveal.slide(0);
    // revert configuration
    Reveal.configure(oldConfig);
};


// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    controlsTutorial: false,
    controlsLayout: "edges",
    history: true,
    pdfSeparateFragments: false,
    slideNumber: true,
    transitionSpeed: "fast",
}).then(() => {
    init('section');
});
</script>



</body>
</html>
